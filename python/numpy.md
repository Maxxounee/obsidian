- [[#Создание матриц (многомерных массивов)|Создание матриц (многомерных массивов)]]
- [[#Свойства|Свойства]]
- [[#Методы создания массивов|Методы создания массивов]]
	- [[#Методы создания массивов#np.empty|np.empty]]
	- [[#Методы создания массивов#np.ones | np.zeros | np.full|np.ones | np.zeros | np.full]]
- [[#Массивы из числовых диапазонов|Массивы из числовых диапазонов]]
- [[#Создание матриц|Создание матриц]]
- [[#Изменение формы массивов|Изменение формы массивов]]
	- [[#Изменение формы массивов#shape|shape]]
	- [[#Изменение формы массивов#reshape|reshape]]
	- [[#Изменение формы массивов#resize|resize]]
	- [[#Изменение формы массивов#ravel|ravel]]
	- [[#Изменение формы массивов#Копирование: view и copy|Копирование: view и copy]]
- [[#Объединение и разделение массивов. Добавление осей|Объединение и разделение массивов. Добавление осей]]
	- [[#Объединение и разделение массивов. Добавление осей#Добавление осей|Добавление осей]]
	- [[#Объединение и разделение массивов. Добавление осей#Удаление осей|Удаление осей]]
	- [[#Объединение и разделение массивов. Добавление осей#Объединение массивов|Объединение массивов]]
		- [[#Объединение массивов#По первой оси (hstack)|По первой оси (hstack)]]
		- [[#Объединение массивов#По нулевой оси (vstack)|По нулевой оси (vstack)]]
		- [[#Объединение массивов#Объединение с помощью concatenate|Объединение с помощью concatenate]]
	- [[#Объединение и разделение массивов. Добавление осей#Разделение массивов|Разделение массивов]]
- [[#Добавление и удаление элементов|Добавление и удаление элементов]]
	- [[#Добавление и удаление элементов#Добавление|Добавление]]
	- [[#Добавление и удаление элементов#Удаление|Удаление]]
	- [[#Добавление и удаление элементов#Еще про добавление|Еще про добавление]]
- [[#Индексация и срезы|Индексация и срезы]]
	- [[#Индексация и срезы#Индексация|Индексация]]
	- [[#Индексация и срезы#Срезы|Срезы]]
	- [[#Индексация и срезы#Списочная индексация (выборка)|Списочная индексация (выборка)]]
- [[#Математические операции и транслирование массивов|Математические операции и транслирование массивов]]
	- [[#Математические операции и транслирование массивов#Операции массивов с числами|Операции массивов с числами]]
	- [[#Математические операции и транслирование массивов#Транслирование несогласованных массивов|Транслирование несогласованных массивов]]
- [[#Математические функции|Математические функции]]
	- [[#Математические функции#Применение математических функций по осям|Применение математических функций по осям]]
	- [[#Математические функции#Статистические функции|Статистические функции]]
	- [[#Математические функции#Генерация случайных чисел|Генерация случайных чисел]]
- [[#Операции сравнения|Операции сравнения]]
	- [[#Операции сравнения#Функции сравнения|Функции сравнения]]
	- [[#Операции сравнения#Полезные функции|Полезные функции]]
- [[#Матрицы и вектора|Матрицы и вектора]]
	- [[#Матрицы и вектора#Линейная алгебра и матрицы|Линейная алгебра и матрицы]]

## Создание матриц (многомерных массивов)

```python
# Одномерный массив
np.arange(6)
''' [0, 1, 2, 3, 4, 5] '''
# Двумерный массив
np.arange(20).reshape(4, 5) # 4 строки, 5 столбцов (читать как 4 элемента на первой оси, 5 элементов на второй оси)
'''
array([
	[0, 1, 2, 3, 4],
	[5, 6, 7, 8, 9],
	[10, 11, 12, 13, 14],
	[15, 16, 17, 18, 19],
])
'''
# трехмерный массив (3 элемента на первой оси, 2 элемента на второй, 2 элемента на третьей)
np.arange(12).reshape(3, 2, 2);
'''
array([
	[ [0, 1], [2, 3] ],
	[ [4, 5], [6, 7] ],
	[ [8, 9], [10, 11] ],
])
'''

# С двух до 8
np.arange(2, 8) 

```

## Свойства

```python
np_array = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
 # Количество осей
np_array.ndim # 2

# Количество элементов
np_array.size # 9

# Количество элементом по осям
np_array.shape # (3, 3) 
# изменение представления массива
np_array = 9, 1 # [[1], [2], [3], [4], ...]

# тип данных массива
np_array.dtype # int32
# Изменение типа данных. Изначально данные были представлены типом int32 и под каждый элемент массива было выделено 4 байта памяти. При изменении на int8, количество выделенной памяти осталось неизменным, поэтому неиспользованная память заполняется нулями. При таком изменении не происходит потери данных и мы можем поменять int8 на int32 обратно.
np_array,dtype = np.int8 # [[1, 0, 0, 0], [2, 0, 0, 0], ...]


```

## Методы создания массивов

### np.empty

```python
# создание массива с неопределенными значениями. Работает быстрее всех остальных методов
np.empty(7)
''' array([2.0985439e-322m 0.000000e+000, 0.99999+000, ...]) '''
# Массив с 3 элементами на первой оси, 2 на второй и одним на третьей
np.empty([3, 2, 1])
# Указание типов данных
np.empty([3, 2, 1], dtype=np.int8)
```

### np.ones | np.zeros | np.full

```python
# Создание матрицы, заполненной единицами
np.ones([3, 2, 2])

# Вернет массив из единиц такого же размера, как переданный np_array
np.ones_like(np_array)

# Матрица, заполненная нулями
np.zeros([3, 2, 2])

# Вернет массив из нулей такого же размера, как переданный np_array
np.zeros_like(np_array)

# Создание матрицы, заполненной N элементами
np.full([3, 2, 2], 7)

# Вернет массив из N-элементов такого же размера, как переданный np_array
np.zeros_like(np_array, 7)
```

## Массивы из числовых диапазонов

```python
# Одномерный массив [0, 1, ..., 5, 6]
np.arrange(7)

# Одномерный массив [7, 8, 9, 10, ..., 16]
np.arrange(7, 17)

# Одномерный массив с шагом [7, 10, 13, 16]
np.arrange(7, 17, 3)

```

## Создание матриц

```python
# Создание матрицы (двумерный массив)
np.mat([1, 2, 3, 4, 5]) # matrix([[1, 2, 3, 4, 5]])

np.mat([[1, 2, 3], [4, 5, 6]]) # matrix([[1, 2, 3], [4, 5, 6]])

# Создание диагональной матрицы
np.diag([1, 2, 3, 4, 5])
'''
array([
	[1, 0, 0, 0, 0],
	[0, 2, 0, 0, 0],
	[0, 0, 3, 0, 0],
	[0, 0, 0, 4, 0],
	[0, 0, 0, 0, 5],
])
'''

# Если передать матрицу, то вернет значения, лежащие на главной диагонали массива
np.diag(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # [1, 5, 9]

# Превращение даже двумерного массива в диагональную матрицу
np.diagflat(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
'''
array([
	[1, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 2, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 3, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 4, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 5, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 6, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 7, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 8, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 9],
])
'''

# Вернет двумерный массив 4х4, где на главной диагонали расположены единицы
np.eye(4)
'''
np.array([
	[1, 0, 0, 0],
	[0, 1, 0, 0],
	[0, 0, 1, 0],
	[0, 0, 0, 1],
])
'''

# Вернет двумерный массив 4х5, где на главной диагонали расположены единицы
np.eye(4, 5)

# Работает как np.eye с одним аргументом
np.identity(5)

# Вернет нижнетреугольную матрицу 7x7
np.tri(7)
'''
np.array([
	[1, 0, 0, 0, 0, 0, 0],
	[1, 1, 0, 0, 0, 0, 0],
	[1, 1, 1, 0, 0, 0, 0],
	[1, 1, 1, 1, 0, 0, 0],
	[1, 1, 1, 1, 1, 0, 0],
	[1, 1, 1, 1, 1, 1, 0],
	[1, 1, 1, 1, 1, 1, 1],
])
'''

# Вернет нижнетреугольную матрицу 7x5
np.tri(7, 5)

# Вернет нежнетреугольную матрицу на основе переданной матрицы
np.tril(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
'''
array([
	[1, 0, 0],
	[4, 5, 0],
	[7, 8, 9]
])
'''

# Вернет нижнетреугольную матрицу на основе массива
np.tril([7, 8, 9])
'''
array([
	[7, 0, 0],
	[7, 8, 0],
	[7, 8, 9],
])
'''

# Аналогичная функция для верхнетреугольной матрицы
np.triu(7, 5)
np.triu(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
np.triu([7, 8, 9])

```

## Изменение формы массивов

### shape

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

np_array.shape = 12
''' array([1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6]) '''

np_array.shape = (2, 6)
''' array([[1, 2, 3, 4, 2, 3], [4, 5, 3, 4, 5, 6]]) '''

# Автоматический расчет элементов
np_array.shape = (4, -1) # 4 элемента на нулевой оси. В остальных - автоматически
''' array([[1, 2, 3], [3, 4, 5], [4, 5, 6], [5, 6, 7]]) '''

```
### reshape

Важно понимать, что np_array и модифицированный через reshape, используют ссылку на один и тот же массив, поэтому изменение исходных данных повлечет и изменение модифицированных

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

np_array.reshape([2, 2, 3], end='\n\n\n')
'''
array([
	[
		[1, 2, 3],
		[4, 2, 3],
	],
	[
		[4, 5, 3],
		[4, 5, 6],
	],
])
'''
```

### resize

Методы shape и reshape должны сохранять изначальное количество элементов.
Resize же позволяет изменять представление матрицы

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

# Тут как в shape, никаких отличий
np_array.resize((2, 6))
''' array([[1, 2, 3, 4, 2, 3], [4, 5, 3, 4, 5, 6]]) '''

# Если хотим получить количество элементов, отличающееся от изначального, то необходимо передать аругмент refcheck=False. При превышении количества элементов относительно оригинального массива, недостающие элементы будут заполнены нулями
np_array.resize((4, 2), refcheck=False)

'''
array([
	[1, 2],
	[3, 4],
	[2, 3],
	[4, 5]
])
'''
np_array.resize((4, 4), refcheck=False)
'''
array([
	[1, 2, 3, 4],
	[2, 3, 4, 5],
	[3, 4, 5, 6],
	[0, 0, 0, 0]
])
'''
```

### ravel

Представление в виде одномерного массива

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

# Представление в виде одномерного массива
np_array.ravel()
''' array([1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6]) '''

```

### Копирование: view и copy

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

# Создание копии представления массива. Работают с одними и теми же исходными данными, так что изменения в исходных данных коснутся обоих представлений. Но, изменения оригинального представления np_array не повлекут за собой изменения new_array (например, изменения через shape)
new_array = np_array.view()

# Создание полной копии, независимой от оригинальных данных
new_array_copy = np_array.copy()
```

## Объединение и разделение массивов. Добавление осей

### Добавление осей

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])
print(np_array.shape) # (3, 4)

# Добавление оси с индексом 0
new_array = np.expand_dims(np_array, axis=0)
print(new_array.shape) # (1, 3, 4)

# Еще один способ добавить ось
# добавит нулевую ось
new_array = np_array[np.newaxis] 
print(new_array.shape) # (1, 3, 4)

# С помощью среза добавляем ось под индексом 1
new_array = np_array[ :, np.newaxis] 
print(new_array.shape) # (3, 1, 4)

# С помощью среза добавляем ось под индексом 1
new_array = np_array[ :, np.newaxis] 
print(new_array.shape) # (3, 1, 4)

# С помощью срезов добавляем ось под индексом 2
new_array = np_array[ :, :, np.newaxis]
print(new_array.shape) # (3, 4, 1)

# С помощью spread добавим ось в конец
new_array = np_array[..., p.newaxis]
print(new_array.shape) # (3, 4, 1)

```

### Удаление осей

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

new_array = np.expand_dims(np_array, axis=0)
print(new_array.shape) # (1, 3, 4)

# удалит только те оси, которые имеют один элемент
new_array = np.squeeze(new_array)

print(new_array.shape) # (3, 4)
```

### Объединение массивов

#### По первой оси (hstack)

При использовании hstack важно понимать, что количество элементов на всех осях, кроме первой (i = 1), должно совпадать

```python
arr_1 = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
arr_2 = np.array([[4, 5, 6], [5, 6, 7], [7, 8, 9]])
arr_3 = np.array([[7, 8, 9, 10], [8, 9, 10, 11], [9, 10, 11, 12]])

print(arr_1.shape, arr_2.shape, arr_3.shape) # (3, 3), (3, 3), (3, 4)

# Объединение по первой оси hstack
new_array = np.hstack([arr_1, arr_2, arr_3])
'''
shape -> (3, 10)
array([
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
	[2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
	[3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
])
'''


arr_1 = np.empty([27, 8, 3])
arr_2 = np.empty([27, 10, 3])
arr_3 = np.empty([27, 9, 3])

new_array = np.hstack([arr_1, arr_2, arr_3])
print(new_arr.shape) # (27, 27, 3)
```

#### По нулевой оси (vstack)

Количество элементов на всех осях, кроме нулевой, должны совпадать

```python
arr_1 = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
arr_2 = np.array([[4, 5, 6], [5, 6, 7], [7, 8, 9]])
arr_3 = np.array([[7, 8, 9, 10], [8, 9, 10, 11], [9, 10, 11, 12]])

print(arr_1.shape, arr_2.shape, arr_3.shape) # (3, 3), (3, 3), (3, 4)

# Объединение по нулевой оси vstack
arr_1 = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
arr_2 = np.array([[4, 5, 6], [5, 6, 7], [7, 8, 9]])
arr_3 = np.array([[7, 8, 9], [8, 9, 10], [9, 10, 11], [10, 11, 12]])

print(arr_1.shape, arr_2.shape, arr_3.shape) # (3, 3), (3, 3), (4, 3)

new_array = np.vstack([arr_1, arr_2, arr_3])
'''
shape -> (10, 3)
array([
	[1, 2, 3],
	[2, 3, 4],
	[3, 4, 5],
	[4, 5, 6],
	[5, 6, 7],
	[6, 7, 8],
	...,
	[10, 11, 12]
])
'''

arr_1 = np.empty([9, 27, 3])
arr_2 = np.empty([10, 27, 3])
arr_3 = np.empty([8, 27, 3])

new_array = np.vstack([arr_1, arr_2, arr_3])

print(new_array.shape) # (27, 27, 3)

```

#### Объединение с помощью concatenate

```python
arr_1 = np.empty([27, 27, 1])
arr_2 = np.empty([27, 27, 1])
arr_3 = np.empty([27, 27, 1])

# Объединение по оси i = 2
new_array = np.contactenate([arr_1, arr_2, arr_3], axis = 2)

'''
shape -> (27, 27, 3)

array([
	[
		[n, n, n], # 1
		[n, n, n], # 2
		...,       # 3 - 26
		[n, n, n]  # 27
	],
	...,           # 2 - 26
	[
		[n, n, n], # 1
		[n, n, n], # 2
		...,       # 3 - 26
		[n, n, n]  # 27
	]              # 27
])
'''
```

### Разделение массивов

```python
arr_1 = np.array([
			['x_1', 'y_1'],
			['x_2', 'y_2'],
			['x_3', 'y_3'],
			['x_4', 'y_4']
		])

# Аргументы: массив; На сколько частей разделить массив; Ось, по которой массив будет разрезан

arr_list = np.array_split(arr1, 4, axis = 0)

'''
[
	array([['x_1', 'y_1']], dtype='<U3'),
	array([['x_2', 'y_2']], dtype='<U3'),
	array([['x_3', 'y_3']], dtype='<U3'),
	array([['x_4', 'y_4']], dtype='<U3')
]
'''

arr_list = np.array_split(arr1, 2, axis = 1)

'''
[
	array([['x_1'], ['y_1']]),
	array([['x_2'], ['y_2']]),
	array([['x_3'], ['y_3']]),
	array([['x_4'], ['y_4']]),
]
'''

```

## Добавление и удаление элементов

### Добавление

```python
data = np.empty([1000, 28, 28])
arr_1 = np.empty([50, 28, 28])
arr_2 = np.empty([28, 28])

new_data = np.append(data, arr_1)
print(new_data.shape) # (823200,)

# Количество элементов может различаться только по оси axis
new_data = np.append(data, arr_1, axis=0)
print(new_data.shape) # (1050, 28, 28)

new_data = np.append(arr_1, arr_1, axis=2)
print(new_data.shape) # (50, 28, 56)

new_data = np.append(data, arr_2[np.newaxis], axis=0)
print(new_data.shape) # (1001, 28, 28)

```

### Удаление

```python
data = np.empty([1000, 28, 28])

# Удалить из data элемент оси 0 под индексом 1000
new_data = np.delete(data, 1000, axis = 0)
print(np.shape) # 999, 28, 28
```

### Еще про добавление

```python
# Плохой пример. Работает медленно
%%time
arr_1 = np.empty([1000, 28, 28])

fir i in range(1000):
	img = np.random.randint(0, 255, 28*28).reshape([28, 28])
	arr_1 = np.append(arr_1, img[np.newaxis], axis=0)


# более быстрый пример с расширением. Этот вариант быстрее, потому что мы не добавляем элементы в массив, а изменяем существующие

%%time
arr_1 = np.empty([1000, 28, 28])
arr.resize([2000, 28, 28])

for i in range(1000):
	img = np.random.randint(0, 255, 28*28).reshape([28, 28])
	arr[1000+i] = img
	
```

## Индексация и срезы

### Индексация

```python
arr = np.array([1, 2, 3, 4, 5])
arr[3] # 4

arr = np.arange(18).reshape(3, 3, 2)
'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	]
]
'''
arr[0] # [[0, 1], [2, 3], [4, 5]],
arr[2, 0] # [12, 13]
arr[2, 2, 0] # 16

# Можно и менять с помощью срезов
arr[1, 2] = [100, 101]
arr[0, 0, 1] = 7
```

### Срезы

```python
arr = np.arange(4*3*2).reshape([4, 3, 2])

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
]
'''
# Взять второй элемент из 0 и 1 элементов нулевой оси 
arr[0:2, 2] # [[4, 5], [10, 11]]

# Полный срез
arr[:, 1] # [[2, 3], [8, 9], [14, 15], [20, 21]]

# С первого и далее
arr[1:, :, 1] # [[7, 9, 11], [13, 15, 17], [19, 21, 23]]

# Каждый второй
arr[::2, 2] # [[10, 11], [22, 23]]

###########

# Изменение 
arr[:, 2] = 100

'''
[
	[
		[0, 1],
		[2, 3],
		[100, 100]
	],
	[
		[6, 7],
		[8, 9],
		[100, 100]
	],
	[
		[12, 13],
		[14, 15],
		[100, 100]
	],
	[
		[18, 19],
		[20, 21],
		[100, 100]
	],
]
'''
```

### Списочная индексация (выборка)

```python
arr = np.arange(4*3*2).reshape([4, 3, 2])

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
]
'''

# Собирает новый массив из элементов под индексами [1, 3, 1, 2, 0] по нулевой оси

arr[[1, 3, 1, 2, 0]]
'''
[
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	],
	[
		[0, 1],
		[2, 3],
		[4, 5]
	]
]
'''

# Выборка с помощью булевых значений. Важно, чтобы количество элементов совпадало с количеством элементов по нулевой оси

arr[[True, False, False, True]]

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
]
'''

#########

arr = np.arange(3*2).reshape([3, 2])
'''
[
	[0, 1],
	[2, 3],
	[4, 5]
]
'''

index = np.array([0, 0, 1], [1, 0, 2])

# Создает новое представление, согласно массивам index. (2 массива из элементов под индексами 0 0 1 и 1 0 2 соответственно)

arr[index]
'''
[
	[
		[0, 1],
		[0, 1],
		[2, 3]
	],
	[
		[2, 3],
		[0, 1],
		[4, 5]
	],
]
'''
```

## Математические операции и транслирование массивов

### Операции массивов с числами
Все операции с числами выполняются поэлементно

```python
arr_1 = np.arange(6).reshape(3, 2)
arr_2 = np.arange(10, 16).reshapce(3, 2)
'''
[[0, 1], [2, 3], [4, 5]]
[[10, 11], [12, 13], [14, 15]]
'''

arr_1 + 5 # [[5, 6], [7, 8], [9, 10]]

# Операции с массивами одинакового размера (с согласованными массивами)
arr_1 + arr_2 # [[10, 12], [14, 16], [18, 20]]
```

### Транслирование несогласованных массивов

*Правила транслирования массивов:*
1. Если массивы имеют разное количество осей, то к массиву с меньшим количеством добавляются новые, чтобы размерности совпали. Автоматически добавление осей происходит слева, но самом можно добавить любые оси
2. В массивах на соответствующих осях должно быть или одинаковое количество элементов, или один элемент в одном из массивов

numpy делает транслирование автоматически, если это возможно

```python
arr_1 = np.arange(4*3).reshape(4, 3)
'''
[[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]
'''

arr_2 = np.arange(3)
'''
[1, 2, 3]
'''

# arr_2 должен преобрести форму (shape) (1, 3). Тогда выполняется правило номер один. И из-за того, что во втором правиле сказано, что на соотвествующих осях должно быть или одинаковое количество элементов, или один, то и второе правило выполняется
'''
[
	[1, 2, 3],
	[1, 2, 3],
	[1, 2, 3],
	[1, 2, 3],
]
'''

# Согласованные массивы:
# (4, 3, 5) и 7 - массив любого размера всегда согласован с числом
# (4, 3, 5) и (1) - Массив всегда согласован с массивом, в котором всего один элемент
# (4, 3, 5) и (5) - Во втором массиве размерность (1, 1, 5)

# Несогласованные массивы:
# (4, 3, 5) и (4) - (4, 3, 5) и (1, 1, 4) - несогласованы
# Массивы можно согласовать, добавив оси таким образом, чтобы размерность второго массива получилась (4, 1, 1)


arr = np.arange(5*3*2).reshape([5, 3, 2]) # shape -> (5, 3, 2)
'''
[
	[[0, 1], [2, 3], [4, 5]],
	[[6, 7], [8, 9], [10, 11]],
	[[12, 13], [14, 15], [16, 17]],
	[[18, 19], [20, 21], [22, 23]],
	[[24, 25], [26, 27], [28, 29]],
]
'''
arr_1 = np.array([5, 6, 7, 8, 9]) # shape -> (5)

# Нужно подвести arr_1 по правилам транслирования массивов
arr_1.shape = (5, 1, 1)
'''
[
	[[5]], [[6]], [[7]], [[8]], [[9]],
]
'''

# Теперь с массивами можно производить математические операции
arr - arr_1
'''
[
	[[-5, -4], [-3, -2], [-1, 0]],
	[[0, 1], [2, 3], [4, 5]],
	[[5, 6], [7, 8], [9, 10]],
	[[10, 11], [12, 13], [14, 15]],
	[[15, 16], [17, 18], [19, 20]],
]
'''
```


## Математические функции

```python
arr = np.arange(2, 20).reshape([3, 3, 2])
'''
[
	[
		[2, 3],
		[4, 5],
		[6, 7],
	],
	[
		[8, 9],
		[10, 11],
		[12, 13],
	],
	[
		[14, 15],
		[16, 17],
		[18, 19],
	],
]
'''

arr.min() # 2
arr.max() # 19
arr.sum() # 189
arr.mean() # 10.5

np.abs(np.array([-1, 2, -3], [-2, 1, 3])) # [1, 2, 3], [2, 1, 3]
np.max(arr) # 3
np.log(arr) # логарифм для каждого элемента
np.exp(arr) # Экспонента для каждого элемента
np.log(np.exp(arr))

np.sin(arr) # синус над каждым элементом
np.cos(arr)
np.arctan(arr)
```

### Применение математических функций по осям

Понять, какой размер будет в результирующем массиве, можно убрав значение той оси, по которой мы выполняем преобразование, из shape.

```python 
arr = np.arange(2, 20).reshape([3, 3, 2]) # shape -> (3, 3, 2)

'''
[
	[
		[2, 3],
		[4, 5],
		[6, 7],
	],
	[
		[8, 9],
		[10, 11],
		[12, 13],
	],
	[
		[14, 15],
		[16, 17],
		[18, 19],
	],
]
'''

np.sum(arr, axis=0) # [[24, 27], [30, 33], [36, 39]]

np.mean(arr, axis=1) # [[4., 5.], [10., 11.], [16., 17.]]

np.max(arr, axis=2) # [[3, 5, 7], [9, 11, 13], [15, 17, 19]]


# Примеры
# Пример 1. Есть пять точек с координатами x и y
arr = np.arange(10).reshape([5, 2])
'''
[
	[0, 1],
	[2, 3],
	[4, 5],
	[6, 7],
	[8, 9],
]
'''
# Задача. Посчитать среднее значение координат x и y
# Нужно взять элементы на нулевой оси и поэлементно посчитать среднее. Для этого в функции нужно указать нулевую ось
np.mean(arr, axis=0) # [4., 5]

# =========

# Пример 2. Есть массив трех картинок, с тремя объектами на каждой и у каждого объекта 2 координаты: x и y
arr = np.arange(18).reshape([3, 3, 2])

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5],
	],
	[
		[6, 7],
		[8, 9],
		[10, 11],
	],
	[
		[12, 13],
		[14, 15],
		[16, 17],
	],
]
'''
# задача 1. Посчитать средние координаты x и y на каждой картинке
# Чтобы посчитать координаты, нужно рассуждать следующим образом: чтобы получить среднее для x и y, то ось i=2 мы не трогаем. Так же, нам нужно получить среднее для каждой картинки, так что ось i=0 мы тоже не трогаем.
np.mean(arr, axis=1) # [[2., 3.], [8., 9.], [14., 15.]]

# Задача 2. Посчитать среднее значение координат x и y для всех картинок
# Поскольку нам нужно посчитать среднее значение координат x и y, то ось i=2 мы не трогаем. Среднее нужно посчитать для всех картинок и для всех объектов. Мы можем поступить двумя способами: 

# 1. изменить размер массива
arr.shape = -1, 2
'''
[[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]. [10, 11], [12, 13], [14, 15], [16, 17]]
'''
arr.mean(arr, axis=0) # [8., 9.]

# 2. Взять среднее по оси i=0 и i=1, передав в axis кортеж
arr.mean(arr, axis=(0, 1)) # [8., 9.]

# ==========

# Пример 3
# Есть 3 картинки размером 4х4 пикселя с тремя цветовыми каналами
arr = np.arange(3*4*4*3).reshape([3, 4, 4, 3])

# Задача 1. Посчитать среднее значение для каждого цветового канала для каждой картинки отдельно.
# Будем считать каналы, поэтому их не трогаем. Расчеты нужны для каждой картинки, их тоже не трогаем.

# Вариант 1. Поменять размер массива и посчитать среднее по оси i=1
arr.shape = [3, 4*4, 3]
np.mean(arr, axis=1) # shape -> (3, 3)

# Вариант 2. Указать кортеж для axis
np.mean(arr, axis=(1, 2)) # shape -> (3, 3)


# Задача 2. Посчитать среднее значение каждого цветового канала для всего массива
# В этой задаче так же не трогаем ось i=3, так как в ней лежат эти цветовые каналы. А считать среднее нам нужно по осям 0, 1 и 2

# Вариант 1
arr.shape = -1, 3
np.mean(arr, axis=0) # shape -> (3)

# Вариант 2
np.mean(arr, axis=(0, 1, 2)) # shape -> (3)
```

### Статистические функции

```python
np.median(arr) # медиана
np.var(arr) # дисперсия
np.std(arr) # стандартное отклонение
```

### Генерация случайных чисел

```python
# Равномерное распределение - каждый результат одинаково вероятен.

# Нормальное распределение - график вероятности имеет колоколообразную форму, где вероятность больше в центре и меньше - к краям.

# Стандартное отклонение - разброс значение относительно среднего значения

# Дискретное равномерное распределение - распределение случайной величины, принимающей значения, принадлежащие некторому промежутку конечной длины

# ========


# Массив заданной формы, равномерное распределение [0, 1) (единица не включена)

np.random.rand() # 0.3215131
np.random.rand(4) # [0.12331, 0.5423590, 0.5342, 0.51343950]
np.random.rand(3, 2) # [[0.321, 0.476], [0.123151, 0.76432], [0.987, 0.1589]]


# Стандартное нормальное распределение

np.random.randn()
np.random.randn(6)
np.random.randn(3, 2)


# Normal. Нормальное распределение. Вернет число из нормального распределения с указанным средним и стандартным отклонением

# 5 - среднее, 10 - стандартное отклонение
np.random.normal(5, 10) # 33.138947

# 100 - количество элементов
np.random.normal(5, 10, 100)

# 4, 2 - shape
np.random.normal(5, 10, [4, 2])


# Дискретное равномерное распределение
# От нуля до 5 (5 - не включено)
np.random.randint(5) # 3
# От четырех до 10, где 10 не включена
np.ranom.ranint(4, 10)
# От 4 до 10. Shape -> 4, 2
np.ranom.randint(4, 20, size=(4, 2))


# Массив из 10 элементов, состоящий из элементов массива [1, 2, 3, 4, 5], где каждый элемент берется с одинаковой вероятностью
np.random.choice([1, 2, 3, 4, 5], 10)

# Перемешать массив по нулевой оси
np.random.shuffle(arr)

# Установка seed в инстанс random. После чего рандомизирующие функции будут выдавать одинаковое значение для опредленных входных данных
np.random.seed(42)
np.random.rand(3, 2) # всегда будет одинаковый результат
```

## Операции сравнения

```python
np.ranom.seed(42)

arr_1 = np.random.randint(10, size=[4, 3])
'''
[
	[6, 3, 7],
	[4, 6, 9],
	[2, 6, 7],
	[4, 3, 7],
]
'''
arr_2 = arr_1[[2, 1, 2, 0]]

'''
[
	[2, 6, 7],
	[4, 6, 9],
	[2, 6, 7],
	[6, 3, 7]
]
'''

# Сравнение с числом. 
arr_1 == 4

'''
[
	[False, False, False],
	[True, False, False],
	[False, False, False],
	[True, False, False],
]
'''

arr_1 <= 3
'''
[
	[False, True, False],
	[False, False, False],
	[True, False, False],
	[True, True, False],
]
'''
# Часто используются для фильтрации данных
arr_1[ arr_1 > 4 ]
'''
[6, 7, 6, 9, 6, 7, 7]
'''

# Сравнение массивов одинаковых размеров. Массивы сравниваются поэлементно

arr_1 == arr_2
'''
[
	[False, False, True],
	[True, True, True],
	[True, True, True],
	[False, True, True],
]
'''
# ========

# Сравнение согласованных массивов разных размеров
arr_3 = np.random.randint(10, size=[2, 3, 2])
shape_3_2 = np.arange(2, 8).reshape([3, 2])

'''
arr_3 = [
	[
		[6, 3],
		[7, 4],
		[6, 9]
	],
	[
		[2, 6],
		[7, 4],
		[3, 7]
	],
]
shape_3_2 = [
	[2, 3],
	[4, 5],
	[6, 7]
]
'''

arr_3 == [7, 3] # shape -> (1, 2)

'''
[
	[ [False, True], [True, Fallse], [False, False] ],
	[ [False, False], [True, False], [False, False] ],
]
'''

arr_3 == shape_3_2
'''
[
	[ [False, True], [False, False], [True, False] ],
	[ [True, False], [False, False], [False, True] ]
]
'''

```

### Функции сравнения

```python
np.greater(arr_1, arr_2) # >
np.greater_equal() # >=
np.less() # <
np.less_equal() # <=
np.equal() # ==
np.not_equal # !=

```

### Полезные функции

```python
np.all(arr < 5) # Вернет Boolean.
np.any(arr < 5) # Вернет Boolean.

```


## Матрицы и вектора

Матрица - прямоугольная таблица чисел, представленная в виде массивов

```python
vector_1 = np.array([1, 2, 3, 4, 5])
vector_2 = np.array([2, 3, 4, 5, 6])

matrix_1 = np.random.randint(10, size=[3, 3])
matrix_2 = np.random.randint(10, size=[3, 3])

# Умножение векторов. Скалярное произведение (Сумма произведений соответствующих координат векторов). Вычислить можно несколькими способами
# Способ 1
np.dot(vector_1, vector_2) # 70

# Способ 2
vector_1 @ vector_2 # 70

# Способ 3
np.inner(vector_1, vector_2) # 70

# Внешнее произведение. Первый элемент первого вектора умножается на всю строку второго. Второй элемент на вторую и так далее

np.outer(vector_1, vector_2)
'''
[
	[2, 3, 4, 5, 6],
	[4, 7, 8, 10, 12],
	[6, 9, 12, 15, 18],
	[8, 12, 16, 20, 24],
	[10, 15, 20, 25, 30],
]
'''


# =========

# Умножение матриц (Строка на столбец)

np.dot(matrix_1, matrix_2)
np.matmul(matrix_1, matrix_2)
matrix_1 @ matrix_2


# Умножение матриц на вектора

vec_1 = np.array([1, 2, 3])
vec_2 = np.array([2, 3, 4, 5])
mat = np.random.randint(10, size=[4, 3])

np.dot(vec_2, mat)
vec_2 @ mat

```

### Линейная алгебра и матрицы

```python
np.linalg.matrix_rank(mat) # ранг матрицы (количество ненулевых строк)
np.trace(mat) # след матрицы (сумма элементов главной диагонали)
np.linalg.det(mat[:3]) # детерминант. Определитель матрицы
np.linalg.eig(mat[:3]) # Собственные значения и собственные вектора матрицы
np.linalg.inv(mat[:3]) # обратная матрица
np.linalg.svd(mat) # сингулярное разложение
```