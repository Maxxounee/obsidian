## Создание матриц (многомерных массивов)

```python
# Одномерный массив
np.arange(6)
''' [0, 1, 2, 3, 4, 5] '''
# Двумерный массив
np.arange(20).reshape(4, 5) # 4 строки, 5 столбцов (читать как 4 элемента на первой оси, 5 элементов на второй оси)
'''
array([
	[0, 1, 2, 3, 4],
	[5, 6, 7, 8, 9],
	[10, 11, 12, 13, 14],
	[15, 16, 17, 18, 19],
])
'''
# трехмерный массив (3 элемента на первой оси, 2 элемента на второй, 2 элемента на третьей)
np.arange(12).reshape(3, 2, 2);
'''
array([
	[ [0, 1], [2, 3] ],
	[ [4, 5], [6, 7] ],
	[ [8, 9], [10, 11] ],
])
'''

```

## Свойства

```python
np_array = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
 # Количество осей
np_array.ndim # 2

# Количество элементов
np_array.size # 9

# Количество элементом по осям
np_array.shape # (3, 3) 
# изменение представления массива
np_array = 9, 1 # [[1], [2], [3], [4], ...]

# тип данных массива
np_array.dtype # int32
# Изменение типа данных. Изначально данные были представлены типом int32 и под каждый элемент массива было выделено 4 байта памяти. При изменении на int8, количество выделенной памяти осталось неизменным, поэтому неиспользованная память заполняется нулями. При таком изменении не происходит потери данных и мы можем поменять int8 на int32 обратно.
np_array,dtype = np.int8 # [[1, 0, 0, 0], [2, 0, 0, 0], ...]


```

## Методы создания массивов

### np.empty

```python
# создание массива с неопределенными значениями. Работает быстрее всех остальных методов
np.empty(7)
''' array([2.0985439e-322m 0.000000e+000, 0.99999+000, ...]) '''
# Массив с 3 элементами на первой оси, 2 на второй и одним на третьей
np.empty([3, 2, 1])
# Указание типов данных
np.empty([3, 2, 1], dtype=np.int8)
```

### np.ones | np.zeros | np.full

```python
# Создание матрицы, заполненной единицами
np.ones([3, 2, 2])

# Вернет массив из единиц такого же размера, как переданный np_array
np.ones_like(np_array)

# Матрица, заполненная нулями
np.zeros([3, 2, 2])

# Вернет массив из нулей такого же размера, как переданный np_array
np.zeros_like(np_array)

# Создание матрицы, заполненной N элементами
np.full([3, 2, 2], 7)

# Вернет массив из N-элементов такого же размера, как переданный np_array
np.zeros_like(np_array, 7)
```

## Массивы из числовых диапазонов

```python
# Одномерный массив [0, 1, ..., 5, 6]
np.arrange(7)

# Одномерный массив [7, 8, 9, 10, ..., 16]
np.arrange(7, 17)

# Одномерный массив с шагом [7, 10, 13, 16]
np.arrange(7, 17, 3)

```

## Создание матриц

```python
# Создание матрицы (двумерный массив)
np.mat([1, 2, 3, 4, 5]) # matrix([[1, 2, 3, 4, 5]])

np.mat([[1, 2, 3], [4, 5, 6]]) # matrix([[1, 2, 3], [4, 5, 6]])

# Создание диагональной матрицы
np.diag([1, 2, 3, 4, 5])
'''
array([
	[1, 0, 0, 0, 0],
	[0, 2, 0, 0, 0],
	[0, 0, 3, 0, 0],
	[0, 0, 0, 4, 0],
	[0, 0, 0, 0, 5],
])
'''

# Если передать матрицу, то вернет значения, лежащие на главной диагонали массива
np.diag(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # [1, 5, 9]

# Превращение даже двумерного массива в диагональную матрицу
np.diagflat(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
'''
array([
	[1, 0, 0, 0, 0, 0, 0, 0, 0],
	[0, 2, 0, 0, 0, 0, 0, 0, 0],
	[0, 0, 3, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 4, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 5, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 6, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 7, 0, 0],
	[0, 0, 0, 0, 0, 0, 0, 8, 0],
	[0, 0, 0, 0, 0, 0, 0, 0, 9],
])
'''

# Вернет двумерный массив 4х4, где на главной диагонали расположены единицы
np.eye(4)
'''
np.array([
	[1, 0, 0, 0],
	[0, 1, 0, 0],
	[0, 0, 1, 0],
	[0, 0, 0, 1],
])
'''

# Вернет двумерный массив 4х5, где на главной диагонали расположены единицы
np.eye(4, 5)

# Работает как np.eye с одним аргументом
np.identity(5)

# Вернет нижнетреугольную матрицу 7x7
np.tri(7)
'''
np.array([
	[1, 0, 0, 0, 0, 0, 0],
	[1, 1, 0, 0, 0, 0, 0],
	[1, 1, 1, 0, 0, 0, 0],
	[1, 1, 1, 1, 0, 0, 0],
	[1, 1, 1, 1, 1, 0, 0],
	[1, 1, 1, 1, 1, 1, 0],
	[1, 1, 1, 1, 1, 1, 1],
])
'''

# Вернет нижнетреугольную матрицу 7x5
np.tri(7, 5)

# Вернет нежнетреугольную матрицу на основе переданной матрицы
np.tril(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
'''
array([
	[1, 0, 0],
	[4, 5, 0],
	[7, 8, 9]
])
'''

# Вернет нижнетреугольную матрицу на основе массива
np.tril([7, 8, 9])
'''
array([
	[7, 0, 0],
	[7, 8, 0],
	[7, 8, 9],
])
'''

# Аналогичная функция для верхнетреугольной матрицы
np.triu(7, 5)
np.triu(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))
np.triu([7, 8, 9])

```

## Изменение формы массивов

### shape

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

np_array.shape = 12
''' array([1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6]) '''

np_array.shape = (2, 6)
''' array([[1, 2, 3, 4, 2, 3], [4, 5, 3, 4, 5, 6]]) '''

# Автоматический расчет элементов
np_array.shape = (4, -1) # 4 элемента на нулевой оси. В остальных - автоматически
''' array([[1, 2, 3], [3, 4, 5], [4, 5, 6], [5, 6, 7]]) '''

```
### reshape

Важно понимать, что np_array и модифицированный через reshape, используют ссылку на один и тот же массив, поэтому изменение исходных данных повлечет и изменение модифицированных

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

np_array.reshape([2, 2, 3], end='\n\n\n')
'''
array([
	[
		[1, 2, 3],
		[4, 2, 3],
	],
	[
		[4, 5, 3],
		[4, 5, 6],
	],
])
'''
```

### resize

Методы shape и reshape должны сохранять изначальное количество элементов.
Resize же позволяет изменять представление матрицы

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

# Тут как в shape, никаких отличий
np_array.resize((2, 6))
''' array([[1, 2, 3, 4, 2, 3], [4, 5, 3, 4, 5, 6]]) '''

# Если хотим получить количество элементов, отличающееся от изначального, то необходимо передать аругмент refcheck=False. При превышении количества элементов относительно оригинального массива, недостающие элементы будут заполнены нулями
np_array.resize((4, 2), refcheck=False)

'''
array([
	[1, 2],
	[3, 4],
	[2, 3],
	[4, 5]
])
'''
np_array.resize((4, 4), refcheck=False)
'''
array([
	[1, 2, 3, 4],
	[2, 3, 4, 5],
	[3, 4, 5, 6],
	[0, 0, 0, 0]
])
'''
```

### ravel

Представление в виде одномерного массива

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

# Представление в виде одномерного массива
np_array.ravel()
''' array([1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6]) '''

```

### Копирование: view и copy

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

# Создание копии представления массива. Работают с одними и теми же исходными данными, так что изменения в исходных данных коснутся обоих представлений. Но, изменения оригинального представления np_array не повлекут за собой изменения new_array (например, изменения через shape)
new_array = np_array.view()

# Создание полной копии, независимой от оригинальных данных
new_array_copy = np_array.copy()
```

## Объединение и разделение массивов. Добавление осей

### Добавление осей

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])
print(np_array.shape) # (3, 4)

# Добавление оси с индексом 0
new_array = np.expand_dims(np_array, axis=0)
print(new_array.shape) # (1, 3, 4)

# Еще один способ добавить ось
# добавит нулевую ось
new_array = np_array[np.newaxis] 
print(new_array.shape) # (1, 3, 4)

# С помощью среза добавляем ось под индексом 1
new_array = np_array[ :, np.newaxis] 
print(new_array.shape) # (3, 1, 4)

# С помощью среза добавляем ось под индексом 1
new_array = np_array[ :, np.newaxis] 
print(new_array.shape) # (3, 1, 4)

# С помощью срезов добавляем ось под индексом 2
new_array = np_array[ :, :, np.newaxis]
print(new_array.shape) # (3, 4, 1)

# С помощью spread добавим ось в конец
new_array = np_array[..., p.newaxis]
print(new_array.shape) # (3, 4, 1)

```

### Удаление осей

```python
np_array = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])

new_array = np.expand_dims(np_array, axis=0)
print(new_array.shape) # (1, 3, 4)

# удалит только те оси, которые имеют один элемент
new_array = np.squeeze(new_array)

print(new_array.shape) # (3, 4)
```

### Объединение массивов

#### По первой оси (hstack)

При использовании hstack важно понимать, что количество элементов на всех осях, кроме первой (i = 1), должно совпадать

```python
arr_1 = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
arr_2 = np.array([[4, 5, 6], [5, 6, 7], [7, 8, 9]])
arr_3 = np.array([[7, 8, 9, 10], [8, 9, 10, 11], [9, 10, 11, 12]])

print(arr_1.shape, arr_2.shape, arr_3.shape) # (3, 3), (3, 3), (3, 4)

# Объединение по первой оси hstack
new_array = np.hstack([arr_1, arr_2, arr_3])
'''
shape -> (3, 10)
array([
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
	[2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
	[3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
])
'''


arr_1 = np.empty([27, 8, 3])
arr_2 = np.empty([27, 10, 3])
arr_3 = np.empty([27, 9, 3])

new_array = np.hstack([arr_1, arr_2, arr_3])
print(new_arr.shape) # (27, 27, 3)
```

#### По нулевой оси (vstack)

Количество элементов на всех осях, кроме нулевой, должны совпадать

```python
arr_1 = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
arr_2 = np.array([[4, 5, 6], [5, 6, 7], [7, 8, 9]])
arr_3 = np.array([[7, 8, 9, 10], [8, 9, 10, 11], [9, 10, 11, 12]])

print(arr_1.shape, arr_2.shape, arr_3.shape) # (3, 3), (3, 3), (3, 4)

# Объединение по нулевой оси vstack
arr_1 = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
arr_2 = np.array([[4, 5, 6], [5, 6, 7], [7, 8, 9]])
arr_3 = np.array([[7, 8, 9], [8, 9, 10], [9, 10, 11], [10, 11, 12]])

print(arr_1.shape, arr_2.shape, arr_3.shape) # (3, 3), (3, 3), (4, 3)

new_array = np.vstack([arr_1, arr_2, arr_3])
'''
shape -> (10, 3)
array([
	[1, 2, 3],
	[2, 3, 4],
	[3, 4, 5],
	[4, 5, 6],
	[5, 6, 7],
	[6, 7, 8],
	...,
	[10, 11, 12]
])
'''

arr_1 = np.empty([9, 27, 3])
arr_2 = np.empty([10, 27, 3])
arr_3 = np.empty([8, 27, 3])

new_array = np.vstack([arr_1, arr_2, arr_3])

print(new_array.shape) # (27, 27, 3)

```

#### Объединение с помощью concatenate

```python
arr_1 = np.empty([27, 27, 1])
arr_2 = np.empty([27, 27, 1])
arr_3 = np.empty([27, 27, 1])

# Объединение по оси i = 2
new_array = np.contactenate([arr_1, arr_2, arr_3], axis = 2)

'''
shape -> (27, 27, 3)

array([
	[
		[n, n, n], # 1
		[n, n, n], # 2
		...,       # 3 - 26
		[n, n, n]  # 27
	],
	...,           # 2 - 26
	[
		[n, n, n], # 1
		[n, n, n], # 2
		...,       # 3 - 26
		[n, n, n]  # 27
	]              # 27
])
'''
```

### Разделение массивов

```python
arr_1 = np.array([
			['x_1', 'y_1'],
			['x_2', 'y_2'],
			['x_3', 'y_3'],
			['x_4', 'y_4']
		])

# Аргументы: массив; На сколько частей разделить массив; Ось, по которой массив будет разрезан

arr_list = np.array_split(arr1, 4, axis = 0)

'''
[
	array([['x_1', 'y_1']], dtype='<U3'),
	array([['x_2', 'y_2']], dtype='<U3'),
	array([['x_3', 'y_3']], dtype='<U3'),
	array([['x_4', 'y_4']], dtype='<U3')
]
'''

arr_list = np.array_split(arr1, 2, axis = 1)

'''
[
	array([['x_1'], ['y_1']]),
	array([['x_2'], ['y_2']]),
	array([['x_3'], ['y_3']]),
	array([['x_4'], ['y_4']]),
]
'''

```

## Добавление и удаление элементов

### Добавление

```python
data = np.empty([1000, 28, 28])
arr_1 = np.empty([50, 28, 28])
arr_2 = np.empty([28, 28])

new_data = np.append(data, arr_1)
print(new_data.shape) # (823200,)

# Количество элементов может различаться только по оси axis
new_data = np.append(data, arr_1, axis=0)
print(new_data.shape) # (1050, 28, 28)

new_data = np.append(arr_1, arr_1, axis=2)
print(new_data.shape) # (50, 28, 56)

new_data = np.append(data, arr_2[np.newaxis], axis=0)
print(new_data.shape) # (1001, 28, 28)

```

### Удаление

```python
data = np.empty([1000, 28, 28])

# Удалить из data элемент оси 0 под индексом 1000
new_data = np.delete(data, 1000, axis = 0)
print(np.shape) # 999, 28, 28
```

### Еще про добавление

```python
# Плохой пример. Работает медленно
%%time
arr_1 = np.empty([1000, 28, 28])

fir i in range(1000):
	img = np.random.randint(0, 255, 28*28).reshape([28, 28])
	arr_1 = np.append(arr_1, img[np.newaxis], axis=0)


# более быстрый пример с расширением. Этот вариант быстрее, потому что мы не добавляем элементы в массив, а изменяем существующие

%%time
arr_1 = np.empty([1000, 28, 28])
arr.resize([2000, 28, 28])

for i in range(1000):
	img = np.random.randint(0, 255, 28*28).reshape([28, 28])
	arr[1000+i] = img
	
```

## Индексация и срезы

### Индексация

```python
arr = np.array([1, 2, 3, 4, 5])
arr[3] # 4

arr = np.arange(18).reshape(3, 3, 2)
'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	]
]
'''
arr[0] # [[0, 1], [2, 3], [4, 5]],
arr[2, 0] # [12, 13]
arr[2, 2, 0] # 16

# Можно и менять с помощью срезов
arr[1, 2] = [100, 101]
arr[0, 0, 1] = 7
```

### Срезы

```python
arr = np.arange(4*3*2).reshape([4, 3, 2])

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
]
'''
# Взять второй элемент из 0 и 1 элементов нулевой оси 
arr[0:2, 2] # [[4, 5], [10, 11]]

# Полный срез
arr[:, 1] # [[2, 3], [8, 9], [14, 15], [20, 21]]

# С первого и далее
arr[1:, :, 1] # [[7, 9, 11], [13, 15, 17], [19, 21, 23]]

# Каждый второй
arr[::2, 2] # [[10, 11], [22, 23]]

###########

# Изменение 
arr[:, 2] = 100

'''
[
	[
		[0, 1],
		[2, 3],
		[100, 100]
	],
	[
		[6, 7],
		[8, 9],
		[100, 100]
	],
	[
		[12, 13],
		[14, 15],
		[100, 100]
	],
	[
		[18, 19],
		[20, 21],
		[100, 100]
	],
]
'''
```

### Списочная индексация (выборка)

```python
arr = np.arange(4*3*2).reshape([4, 3, 2])

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
]
'''

# Собирает новый массив из элементов под индексами [1, 3, 1, 2, 0] по нулевой оси

arr[[1, 3, 1, 2, 0]]
'''
[
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
	[
		[6, 7],
		[8, 9],
		[10, 11]
	],
	[
		[12, 13],
		[14, 15],
		[16, 17]
	],
	[
		[0, 1],
		[2, 3],
		[4, 5]
	]
]
'''

# Выборка с помощью булевых значений. Важно, чтобы количество элементов совпадало с количеством элементов по нулевой оси

arr[[True, False, False, True]]

'''
[
	[
		[0, 1],
		[2, 3],
		[4, 5]
	],
	[
		[18, 19],
		[20, 21],
		[22, 23]
	],
]
'''

#########

arr = np.arange(3*2).reshape([3, 2])
'''
[
	[0, 1],
	[2, 3],
	[4, 5]
]
'''

index = np.array([0, 0, 1], [1, 0, 2])

# Создает новое представление, согласно массивам index. (2 массива из элементов под индексами 0 0 1 и 1 0 2 соответственно)

arr[index]
'''
[
	[
		[0, 1],
		[0, 1],
		[2, 3]
	],
	[
		[2, 3],
		[0, 1],
		[4, 5]
	],
]
'''
```

## Математические операции и транслирование массивов

### Операции массивов с числами
Все операции с числами выполняются поэлементно

```python
arr_1 = np.arange(6).reshape(3, 2)
arr_2 = np.arange(10, 16).reshapce(3, 2)
'''
[[0, 1], [2, 3], [4, 5]]
[[10, 11], [12, 13], [14, 15]]
'''

arr_1 + 5 # [[5, 6], [7, 8], [9, 10]]

# Операции с массивами одинакового размера (с согласованными массивами)
arr_1 + arr_2 # [[10, 12], [14, 16], [18, 20]]
```

### Транслирование несогласованных массивов

*Правила транслирования массивов:*
1. Если массивы имеют разное количество осей, то к массиво с меньшим количеством добавляются новые, чтобы размерности совпали. Автоматически добавление осей происходит слева, но самом можно добавить любые оси
2. В массивах на соответствующих осях должно быть или одинаковое количество элементов, или один элемент в одном из массивов

numpy делает транслирование автоматически, если это возможно

```python
arr_1 = np.arange(4*3).reshape(4, 3)
'''
[[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]
'''

arr_2 = np.arange(3)
'''
[1, 2, 3]
'''

# arr_2 должен преобрести форму (shape) (1, 3). Тогда выполняется правило номер один. И из-за того, что во втором правиле сказано, что на соотвествующих осях должно быть или одинаковое количество элементов, или один, то и второе правило выполняется
'''
[
	[1, 2, 3],
	[1, 2, 3],
	[1, 2, 3],
	[1, 2, 3],
]
'''

# Согласованные массивы:
# (4, 3, 5) и 7 - массив любого размера всегда согласован с числом
# (4, 3, 5) и (1) - Массив всегда согласован с массивом, в котором всего один элемент
# (4, 3, 5) и (5) - Во втором массиве размерность (1, 1, 5)

# Несогласованные массивы:
# (4, 3, 5) и (4) - (4, 3, 5) и (1, 1, 4) - несогласованы
# Массивы можно согласовать, добавив оси таким образом, чтобы размерность второго массива получилась (4, 1, 1)

```
